

import uncertainty.Uncertainty;
import uncertainty.StochasticityEffectType;
import uncertainty.StructuralEffectTypeRepresentation;
import brakesystem.BrakeDisk;





import "http://www.example.org/uncertainty" as uncertaintyModel
import "http://www.example.org/cad" as cadModel
import "http://www.example.org/brakesystem" as brakesystemModel
import "http://vitruv.tools/stoex/Stoex" as stoexModel



reactions: uncertainty2cad
in reaction to changes in uncertaintyModel
execute actions in cadModel


reaction UncertaintyEffectExpressionChanged {
    after element stoexModel::Expression replaced at uncertaintyModel::Effect[expression] 
    call handleBrakeThicknessUncertainty(affectedEObject, affectedEObject.eContainer() as Uncertainty)
}

routine handleBrakeThicknessUncertainty(uncertaintyModel::Effect effect, uncertaintyModel::Uncertainty uncertainty) {

    match {
        val correspondingUncertainties = retrieve many uncertaintyModel::Uncertainty corresponding to uncertainty
        check uncertainty.getUncertaintyLocation().getReferencedComponents().size() == 1
        check uncertainty.getUncertaintyLocation().getReferencedComponents().get(0) instanceof BrakeDisk
    }
    // Check if uncertainty qualifies
    update{
        if (effect === null) return;
        if (effect.stochasticity !== StochasticityEffectType.PROBABILISTIC) return;
        if (effect.representation !== StructuralEffectTypeRepresentation.CONTINOUS) return;
        if (!uncertainty.getUncertaintyLocation().getParameterLocation().equals("brakeDiskThicknessInMM")) return;
        if (effect.getExpression() === null) return;

        for (correspondingUncertainty : correspondingUncertainties) {
            correspondingUncertainty.effect.setExpression(effect.getExpression());
        }
    }
}


