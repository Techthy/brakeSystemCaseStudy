
import java.util.List;
import java.util.HashMap;

import uncertainty.Uncertainty;
import uncertainty.UncertaintyLocation;
import uncertainty.UncertaintyFactory;
import uncertainty.StochasticityEffectType;
import uncertainty.StructuralEffectTypeRepresentation;
import org.eclipse.emf.ecore.util.EcoreUtil;
import brakesystem.BrakeDisk;
import uncertainty.UncertaintyKind;
import cad.Circle;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import tools.vitruv.methodologisttemplate.consistency.utils.StoexConsistencyHelper;


import "http://www.example.org/uncertainty" as uncertaintyModel
import "http://www.example.org/cad" as cadModel
import "http://www.example.org/brakesystem" as brakesystemModel



reactions: uncertainty2cad
in reaction to changes in uncertaintyModel
execute actions in cadModel




reaction UncertaintyEffectSpecificationReferencingBrakeDiskChanged {
    after attribute replaced at uncertaintyModel::Effect[specification] 
    call handleBrakeDiskUncertainty(affectedEObject, affectedEObject.eContainer() as Uncertainty)
}

routine handleBrakeDiskUncertainty(uncertaintyModel::Effect effect, uncertaintyModel::Uncertainty uncertainty) {

    match {
        val correspondingUncertainties = retrieve many uncertaintyModel::Uncertainty corresponding to uncertainty
        check uncertainty.uncertaintyLocation.getReferencedComponents().get(0) instanceof BrakeDisk
    }


    // Check if uncertainty qualifies
    // needs to be a of kind belief
    // the EffectTypes within the Effect shall include continuous and probabilistic		
    update {
        if (effect === null) return;
        if (effect.stochasticity !== StochasticityEffectType.PROBABILISTIC) return;
        if (effect.representation !== StructuralEffectTypeRepresentation.CONTINOUS) return;
        if(effect.getSpecification() === null) return;


        val stoexConsistencyHelper = new StoexConsistencyHelper();
        stoexConsistencyHelper.putVariable("var1", "Normal(0.0, 4.0)");
        stoexConsistencyHelper.putVariable("var2", effect.getSpecification());
        val expression = "var1 + var2"
        val result = stoexConsistencyHelper.evaluateExpression(expression);


        // Update corresponding uncertainties with the calculated result
        // TODO: do that possibly only for the component we want to be affected ...
        for (correspondingUncertainty : correspondingUncertainties) {
            correspondingUncertainty.effect.specification = result;
        } 
    }
}
