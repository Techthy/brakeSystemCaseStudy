
import java.util.List;
import java.util.HashMap;

import uncertainty.Uncertainty;
import uncertainty.UncertaintyLocation;
import uncertainty.UncertaintyFactory;
import uncertainty.StochasticityEffectType;
import uncertainty.StructuralEffectTypeRepresentation;
import org.eclipse.emf.ecore.util.EcoreUtil;
import brakesystem.BrakeDisk;
import uncertainty.UncertaintyKind;
import cad.Circle;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import tools.vitruv.methodologisttemplate.consistency.utils.StoexConsistencyHelper;


import "http://www.example.org/uncertainty" as uncertaintyModel
import "http://www.example.org/cad" as cadModel
import "http://www.example.org/brakesystem" as brakesystemModel



reactions: uncertainty2cad
in reaction to changes in uncertaintyModel
execute actions in cadModel




reaction UncertaintyEffectSpecificationReferencingBrakeDiskChanged {
    after attribute replaced at uncertaintyModel::Effect[specification] 
    call handleBrakeDiskUncertainty(affectedEObject, affectedEObject.eContainer() as Uncertainty)
}

routine handleBrakeDiskUncertainty(uncertaintyModel::Effect effect, uncertaintyModel::Uncertainty uncertainty) {

    match {
        val correspondingUncertainties = retrieve many uncertaintyModel::Uncertainty corresponding to uncertainty
        check uncertainty.uncertaintyLocation.getReferencedComponents().get(0) instanceof BrakeDisk
    }


    update {
        System.out.println("-=-=-=- Handling uncertainty for BrakeDisk" + uncertainty);

        // Check if uncertainty qualifies
        // needs to be a of kind belief
        // the Effect shall have specification that looks like "N=(x,y)"
        // the EffectTypes within the Effect shall include continuous and probabilistic
      

		
        if (effect === null) return;
        if (effect.stochasticity !== StochasticityEffectType.PROBABILISTIC) return;
        if (effect.representation !== StructuralEffectTypeRepresentation.CONTINOUS) return;

        if(effect.getSpecification() === "Effect specification") return;
        if(effect.getSpecification() === null) return;
        if(effect.getSpecification() === "") return;


        val stoexConsistencyHelper = new StoexConsistencyHelper();
        stoexConsistencyHelper.putVariable("var1", "Normal(0.0, 4.0)");
        stoexConsistencyHelper.putVariable("var2", effect.getSpecification());
        val expression = "var1 + var2"
        val result = stoexConsistencyHelper.evaluateExpression(expression);

        System.out.println("    - Evaluated expression: " + expression + " = " + result);

        // Update corresponding uncertainties with the calculated result
        // TODO: do that possibly only for the component we want to be affected ...
        System.out.println("    - Found the following corresponding correspondingUncertainties" + correspondingUncertainties);
        for (correspondingUncertainty : correspondingUncertainties) {
            System.out.println("    - Updating corresponding uncertainty " + correspondingUncertainty + " with effect specification " + result);
            correspondingUncertainty.effect.specification = result;
        } 
    }


}